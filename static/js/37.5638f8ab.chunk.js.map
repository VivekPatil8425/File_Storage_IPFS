{"version":3,"file":"static/js/37.5638f8ab.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/multiformats/src/bytes.ts","../node_modules/multiformats/src/vendor/base-x.js","../node_modules/multiformats/src/bases/base.ts","../node_modules/multiformats/src/bases/base10.ts","../node_modules/multiformats/src/bases/base16.ts","../node_modules/multiformats/src/bases/base2.ts","../node_modules/multiformats/src/bases/base256emoji.ts","../node_modules/multiformats/src/bases/base32.ts","../node_modules/multiformats/src/bases/base36.ts","../node_modules/multiformats/src/bases/base58.ts","../node_modules/multiformats/src/bases/base64.ts","../node_modules/multiformats/src/bases/base8.ts","../node_modules/multiformats/src/bases/identity.ts","../node_modules/multiformats/src/codecs/json.ts","../node_modules/multiformats/src/codecs/raw.ts","../node_modules/multiformats/src/vendor/varint.js","../node_modules/multiformats/src/varint.ts","../node_modules/multiformats/src/hashes/digest.ts","../node_modules/multiformats/src/hashes/identity.ts","../node_modules/multiformats/src/hashes/hasher.ts","../node_modules/multiformats/src/hashes/sha2-browser.ts","../node_modules/multiformats/src/cid.ts","../node_modules/multiformats/src/basics.ts","../node_modules/uint8arrays/src/alloc.ts","../node_modules/uint8arrays/src/util/bases.ts","../node_modules/uint8arrays/src/to-string.ts","../node_modules/@multiformats/multiaddr/src/errors.ts","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js","../node_modules/@babel/runtime/helpers/esm/checkPrivateRedeclaration.js","../node_modules/@babel/runtime/helpers/esm/assertClassBrand.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js","../node_modules/uint8arrays/src/from-string.ts","../node_modules/uint8-varint/src/index.ts","../node_modules/uint8arrays/src/concat.ts","../node_modules/@chainsafe/is-ip/src/parse.ts","../node_modules/@chainsafe/is-ip/src/parser.ts","../node_modules/@chainsafe/is-ip/src/is-ip.ts","../node_modules/@multiformats/multiaddr/src/utils.ts","../node_modules/@multiformats/multiaddr/src/validation.ts","../node_modules/@multiformats/multiaddr/src/registry.ts","../node_modules/@multiformats/multiaddr/src/constants.ts","../node_modules/@multiformats/multiaddr/src/components.ts","../node_modules/@multiformats/multiaddr/src/multiaddr.ts","../node_modules/uint8arrays/src/equals.ts","../node_modules/@chainsafe/netmask/src/ip.ts","../node_modules/@multiformats/multiaddr/src/index.ts","../node_modules/@multiformats/mafmt/src/index.ts","../node_modules/is-ipfs/src/index.ts","../node_modules/iso-url/src/url-browser.js","../node_modules/iso-url/src/relative.js","../node_modules/iso-url/index.js"],"sourcesContent":["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nexport { _objectSpread2 as default };","export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n","import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n","import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n","import { from } from './base.js'\n\nconst alphabet = Array.from('')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n","import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n","import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n","import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n","/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\nimport type { DigestOptions } from './hasher.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array, options?: DigestOptions): Digest.Digest<typeof code, number> {\n  if (options?.truncate != null && options.truncate !== input.byteLength) {\n    if (options.truncate < 0 || options.truncate > input.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`)\n    }\n\n    input = input.subarray(0, options.truncate)\n  }\n\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n","import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20\n\nexport interface HasherInit <Name extends string, Code extends number> {\n  name: Name\n  code: Code\n  encode(input: Uint8Array): Await<Uint8Array>\n\n  /**\n   * The minimum length a hash is allowed to be truncated to in bytes\n   *\n   * @default 20\n   */\n  minDigestLength?: number\n\n  /**\n   * The maximum length a hash is allowed to be truncated to in bytes. If not\n   * specified it will be inferred from the length of the digest.\n   */\n  maxDigestLength?: number\n}\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode, minDigestLength, maxDigestLength }: HasherInit<Name, Code>): Hasher<Name, Code> {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength)\n}\n\nexport interface DigestOptions {\n  /**\n   * Truncate the returned digest to this number of bytes.\n   *\n   * This may cause the digest method to throw/reject if the passed value is\n   * greater than the digest length or below a threshold under which the risk of\n   * hash collisions is significant.\n   *\n   * The actual value of this threshold can depend on the hashing algorithm in\n   * use.\n   */\n  truncate?: number\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n  readonly minDigestLength: number\n  readonly maxDigestLength?: number\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>, minDigestLength?: number, maxDigestLength?: number) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH\n    this.maxDigestLength = maxDigestLength\n  }\n\n  digest (input: Uint8Array, options?: DigestOptions): Await<Digest.Digest<Code, number>> {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`)\n      }\n\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)\n      }\n    }\n\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate)\n      }\n\n      return result.then(digest => createDigest(digest, this.code, options?.truncate))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest <Code extends number> (digest: Uint8Array, code: Code, truncate?: number): Digest.Digest<Code, number> {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`)\n    }\n\n    digest = digest.subarray(0, truncate)\n  }\n\n  return Digest.create(code, digest)\n}\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n","import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n","import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString (array: Uint8Array, encoding: SupportedEncodings = 'utf8'): string {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // strip multibase prefix\n  return base.encoder.encode(array).substring(1)\n}\n","/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n  name = 'InvalidMultiaddrError'\n}\n\nexport class ValidationError extends Error {\n  static name = 'ValidationError'\n  name = 'ValidationError'\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  name = 'InvalidParametersError'\n}\n\nexport class UnknownProtocolError extends Error {\n  static name = 'UnknownProtocolError'\n  name = 'UnknownProtocolError'\n}\n","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nexport { _classPrivateFieldInitSpec as default };","function _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nexport { _checkPrivateRedeclaration as default };","function _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nexport { _assertClassBrand as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldGet2(s, a) {\n  return s.get(assertClassBrand(s, a));\n}\nexport { _classPrivateFieldGet2 as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldSet2(s, a, r) {\n  return s.set(assertClassBrand(s, a), r), r;\n}\nexport { _classPrivateFieldSet2 as default };","import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n","/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n","import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n","import { Parser } from \"./parser.js\";\n\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\n\nconst parser = new Parser();\n\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n\n/** Parse IPv4 `input` into IPv6 with IPv4-mapped bytes, eg ::ffff:1.2.3.4 */\nexport function parseIPv4Mapped(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n\n  const ipv4 = parser.new(input).parseWith(() => parser.readIPv4Addr());\n  if (ipv4 === undefined) {\n    return undefined;\n  }\n\n  return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, ipv4[0], ipv4[1], ipv4[2], ipv4[3]]);\n}\n\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input: string): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input: string, mapIPv4ToIPv6 = false): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n\n  const addr = parser.new(input).parseWith(() => parser.readIPAddr());\n  if (!addr) {\n    return undefined;\n  }\n\n  if (mapIPv4ToIPv6 && addr.length === 4) {\n    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, addr[0], addr[1], addr[2], addr[3]]);\n  }\n\n  return addr;\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n// Heavily inspired by https://doc.rust-lang.org/src/std/net/parser.rs.html\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Fn = (...foo: any) => any;\n\nexport class Parser {\n  private index = 0;\n  private input = \"\";\n\n  new(input: string): this {\n    this.index = 0;\n    this.input = input;\n    return this;\n  }\n\n  /** Run a parser, and restore the pre-parse state if it fails. */\n  readAtomically<T extends Fn>(fn: T): ReturnType<T> {\n    const index = this.index;\n    const result = fn();\n    if (result === undefined) {\n      this.index = index;\n    }\n    return result;\n  }\n\n  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n  parseWith<T extends Fn>(fn: T): ReturnType<T> | undefined {\n    const result = fn();\n    if (this.index !== this.input.length) {\n      return undefined;\n    }\n    return result;\n  }\n\n  /** Peek the next character from the input */\n  peekChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index];\n  }\n\n  /** Read the next character from the input */\n  readChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index++];\n  }\n\n  /** Read the next character from the input if it matches the target. */\n  readGivenChar(target: string): string | undefined {\n    return this.readAtomically(() => {\n      const char = this.readChar();\n      if (char !== target) {\n        return undefined;\n      }\n      return char;\n    });\n  }\n\n  /**\n   * Helper for reading separators in an indexed loop. Reads the separator\n   * character iff index > 0, then runs the parser. When used in a loop,\n   * the separator character will only be read on index > 0 (see\n   * readIPv4Addr for an example)\n   */\n  readSeparator<T extends Fn>(sep: string, index: number, inner: T): ReturnType<T> {\n    return this.readAtomically(() => {\n      if (index > 0) {\n        if (this.readGivenChar(sep) === undefined) {\n          return undefined;\n        }\n      }\n      return inner();\n    });\n  }\n\n  /**\n   * Read a number off the front of the input in the given radix, stopping\n   * at the first non-digit character or eof. Fails if the number has more\n   * digits than max_digits or if there is no number.\n   */\n  readNumber(\n    radix: number,\n    maxDigits: number | undefined,\n    allowZeroPrefix: boolean,\n    maxBytes: number\n  ): number | undefined {\n    return this.readAtomically(() => {\n      let result = 0;\n      let digitCount = 0;\n\n      const leadingChar = this.peekChar();\n      if (leadingChar === undefined) {\n        return undefined;\n      }\n      const hasLeadingZero = leadingChar === \"0\";\n      const maxValue = 2 ** (8 * maxBytes) - 1;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const digit = this.readAtomically(() => {\n          const char = this.readChar();\n          if (char === undefined) {\n            return undefined;\n          }\n          const num = Number.parseInt(char, radix);\n          if (Number.isNaN(num)) {\n            return undefined;\n          }\n          return num;\n        });\n        if (digit === undefined) {\n          break;\n        }\n        result *= radix;\n        result += digit;\n        if (result > maxValue) {\n          return undefined;\n        }\n        digitCount += 1;\n        if (maxDigits !== undefined) {\n          if (digitCount > maxDigits) {\n            return undefined;\n          }\n        }\n      }\n\n      if (digitCount === 0) {\n        return undefined;\n      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n        return undefined;\n      } else {\n        return result;\n      }\n    });\n  }\n\n  /** Read an IPv4 address. */\n  readIPv4Addr(): Uint8Array | undefined {\n    return this.readAtomically(() => {\n      const out = new Uint8Array(4);\n\n      for (let i = 0; i < out.length; i++) {\n        const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n        if (ix === undefined) {\n          return undefined;\n        }\n        out[i] = ix;\n      }\n\n      return out;\n    });\n  }\n\n  /** Read an IPv6 Address. */\n  readIPv6Addr(): Uint8Array | undefined {\n    /**\n     * Read a chunk of an IPv6 address into `groups`. Returns the number\n     * of groups read, along with a bool indicating if an embedded\n     * trailing IPv4 address was read. Specifically, read a series of\n     * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n     * trailing embedded IPv4 address.\n     */\n    const readGroups = (groups: Uint8Array): [number, boolean] => {\n      for (let i = 0; i < groups.length / 2; i++) {\n        const ix = i * 2;\n        // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n        if (i < groups.length - 3) {\n          const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n          if (ipv4 !== undefined) {\n            groups[ix] = ipv4[0];\n            groups[ix + 1] = ipv4[1];\n            groups[ix + 2] = ipv4[2];\n            groups[ix + 3] = ipv4[3];\n\n            return [ix + 4, true];\n          }\n        }\n\n        const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n        if (group === undefined) {\n          return [ix, false];\n        }\n        groups[ix] = group >> 8;\n        groups[ix + 1] = group & 255;\n      }\n      return [groups.length, false];\n    };\n\n    return this.readAtomically(() => {\n      // Read the front part of the address; either the whole thing, or up to the first ::\n      const head = new Uint8Array(16);\n      const [headSize, headIp4] = readGroups(head);\n\n      if (headSize === 16) {\n        return head;\n      }\n\n      // IPv4 part is not allowed before `::`\n      if (headIp4) {\n        return undefined;\n      }\n\n      // Read `::` if previous code parsed less than 8 groups.\n      // `::` indicates one or more groups of 16 bits of zeros.\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n\n      // Read the back part of the address. The :: must contain at least one\n      // set of zeroes, so our max length is 7.\n      const tail = new Uint8Array(14);\n      const limit = 16 - (headSize + 2);\n      const [tailSize] = readGroups(tail.subarray(0, limit));\n\n      // Concat the head and tail of the IP address\n      head.set(tail.subarray(0, tailSize), 16 - tailSize);\n\n      return head;\n    });\n  }\n\n  /** Read an IP Address, either IPv4 or IPv6. */\n  readIPAddr(): Uint8Array | undefined {\n    return this.readIPv4Addr() ?? this.readIPv6Addr();\n  }\n}\n","import { parseIP, parseIPv4, parseIPv6 } from \"./parse.js\";\n\n/** Check if `input` is IPv4. */\nexport function isIPv4(input: string): boolean {\n  return Boolean(parseIPv4(input));\n}\n\n/** Check if `input` is IPv6. */\nexport function isIPv6(input: string): boolean {\n  return Boolean(parseIPv6(input));\n}\n\n/** Check if `input` is IPv4 or IPv6. */\nexport function isIP(input: string): boolean {\n  return Boolean(parseIP(input));\n}\n\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nexport function ipVersion(input: string): 4 | 6 | undefined {\n  if (isIPv4(input)) {\n    return 4;\n  } else if (isIPv6(input)) {\n    return 6;\n  } else {\n    return undefined;\n  }\n}\n","import { isIPv4 } from '@chainsafe/is-ip'\nimport { base32 } from 'multiformats/bases/base32'\nimport { bases } from 'multiformats/basics'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport type { MultibaseCodec } from 'multiformats'\nimport type { SupportedEncodings } from 'uint8arrays/to-string'\n\nexport function bytesToString (base: SupportedEncodings): (buf: Uint8Array) => string {\n  return (buf) => {\n    return uint8ArrayToString(buf, base)\n  }\n}\n\nexport function stringToBytes (base: SupportedEncodings): (value: string) => Uint8Array {\n  return (buf) => {\n    return uint8ArrayFromString(buf, base)\n  }\n}\n\nexport function bytes2port (buf: Uint8Array): string {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset).toString()\n}\n\nexport function port2bytes (port: string | number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, typeof port === 'string' ? parseInt(port) : port)\n\n  return new Uint8Array(buf)\n}\n\nexport function onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = uint8ArrayFromString(addr[0], 'base32')\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.subarray(0, buf.length - 2)\n  const portBytes = buf.subarray(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip4ToBytes = function (ip: string): Uint8Array {\n  ip = ip.toString().trim()\n\n  const bytes = new Uint8Array(4)\n\n  ip.split(/\\./g).forEach((byte, index) => {\n    const value = parseInt(byte, 10)\n\n    if (isNaN(value) || value < 0 || value > 0xff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[index] = value\n  })\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip6ToBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  const sections = ip.split(':', 8)\n\n  let i\n  for (i = 0; i < sections.length; i++) {\n    const isv4 = isIPv4(sections[i])\n    let v4Buffer: Uint8Array | undefined\n\n    if (isv4) {\n      v4Buffer = ip4ToBytes(sections[i])\n      sections[i] = uint8ArrayToString(v4Buffer.subarray(0, 2), 'base16')\n    }\n\n    if (v4Buffer != null && ++i < 8) {\n      sections.splice(i, 0, uint8ArrayToString(v4Buffer.subarray(2, 4), 'base16'))\n    }\n  }\n\n  if (sections[0] === '') {\n    while (sections.length < 8) { sections.unshift('0') }\n  } else if (sections[sections.length - 1] === '') {\n    while (sections.length < 8) { sections.push('0') }\n  } else if (sections.length < 8) {\n    for (i = 0; i < sections.length && sections[i] !== ''; i++) { }\n    const argv: [number, number, ...string[]] = [i, 1]\n    for (i = 9 - sections.length; i > 0; i--) {\n      argv.push('0')\n    }\n    sections.splice.apply(sections, argv)\n  }\n\n  const bytes = new Uint8Array(offset + 16)\n\n  for (i = 0; i < sections.length; i++) {\n    if (sections[i] === '') {\n      sections[i] = '0'\n    }\n\n    const word = parseInt(sections[i], 16)\n\n    if (isNaN(word) || word < 0 || word > 0xffff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[offset++] = (word >> 8) & 0xff\n    bytes[offset++] = word & 0xff\n  }\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const ip4ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 4) {\n    throw new InvalidMultiaddrError('IPv4 address was incorrect length')\n  }\n\n  const result = []\n\n  for (let i = 0; i < buf.byteLength; i++) {\n    result.push(buf[i])\n  }\n\n  return result.join('.')\n}\n\nexport const ip6ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 16) {\n    throw new InvalidMultiaddrError('IPv6 address was incorrect length')\n  }\n\n  const result: string[] = []\n\n  for (let i = 0; i < buf.byteLength; i += 2) {\n    const byte1 = buf[i]\n    const byte2 = buf[i + 1]\n\n    const tuple = `${byte1.toString(16).padStart(2, '0')}${byte2.toString(16).padStart(2, '0')}`\n\n    result.push(tuple)\n  }\n\n  const ip = result.join(':')\n\n  try {\n    const url = new URL(`http://[${ip}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${ip}\"`)\n  }\n}\n\nexport function ip6StringToValue (str: string): string {\n  try {\n    const url = new URL(`http://[${str}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${str}\"`)\n  }\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nexport function mb2bytes (mbstr: string): Uint8Array {\n  return anybaseDecoder.decode(mbstr)\n}\n\nexport function bytes2mb (base: MultibaseCodec<any>): (buf: Uint8Array) => string {\n  return (buf) => {\n    return base.encoder.encode(buf)\n  }\n}\n","import { ValidationError } from './errors.ts'\n\nexport function integer (value: string): void {\n  const int = parseInt(value)\n\n  if (int.toString() !== value) {\n    throw new ValidationError('Value must be an integer')\n  }\n}\n\nexport function positive (value: any): void {\n  if (value < 0) {\n    throw new ValidationError('Value must be a positive integer, or zero')\n  }\n}\n\nexport function maxValue (max: number): (value: any) => void {\n  return (value) => {\n    if (value > max) {\n      throw new ValidationError(`Value must be smaller than or equal to ${max}`)\n    }\n  }\n}\n\nexport function validate (...funcs: Array<(value: string) => void>): (value: string) => void {\n  return (value) => {\n    for (const fn of funcs) {\n      fn(value)\n    }\n  }\n}\n\nexport const validatePort = validate(\n  integer,\n  positive,\n  maxValue(65_535)\n)\n","import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { CID } from 'multiformats'\nimport { base64url } from 'multiformats/bases/base64'\nimport { CODE_CERTHASH, CODE_DCCP, CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_GARLIC32, CODE_GARLIC64, CODE_HTTP, CODE_HTTP_PATH, CODE_HTTPS, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_IPCIDR, CODE_MEMORY, CODE_NOISE, CODE_ONION, CODE_ONION3, CODE_P2P, CODE_P2P_CIRCUIT, CODE_P2P_STARDUST, CODE_P2P_WEBRTC_DIRECT, CODE_P2P_WEBRTC_STAR, CODE_P2P_WEBSOCKET_STAR, CODE_QUIC, CODE_QUIC_V1, CODE_SCTP, CODE_SNI, CODE_TCP, CODE_TLS, CODE_UDP, CODE_UDT, CODE_UNIX, CODE_UTP, CODE_WEBRTC, CODE_WEBRTC_DIRECT, CODE_WEBTRANSPORT, CODE_WS, CODE_WSS } from './constants.ts'\nimport { UnknownProtocolError, ValidationError } from './errors.ts'\nimport { bytes2mb, bytes2onion, bytes2port, bytesToString, ip4ToBytes, ip4ToString, ip6StringToValue, ip6ToBytes, ip6ToString, mb2bytes, onion2bytes, onion32bytes, port2bytes, stringToBytes } from './utils.ts'\nimport { validatePort } from './validation.ts'\nimport type { Registry as RegistryInterface } from './index.ts'\n\nexport const V = -1\n\nexport interface ProtocolCodec {\n  /**\n   * A numeric code that will be used in the binary representation of the tuple.\n   */\n  code: number\n\n  /**\n   * A string name that will be used in the string representation of the addr.\n   */\n  name: string\n\n  /**\n   * Size defines the expected length of the address part of the tuple - valid\n   * values are `-1` (or the `V` constant) for variable length (this will be\n   * varint encoded in the binary representation), `0` for no address part or a\n   * number that represents a fixed-length address.\n   */\n  size?: number\n\n  /**\n   * If this protocol is a path protocol.\n   *\n   * @deprecated This will be removed in a future release\n   */\n  path?: boolean\n\n  /**\n   * If this protocol can be resolved using configured resolvers.\n   *\n   * @deprecated This will be removed in a future release\n   */\n  resolvable?: boolean\n\n  /**\n   * If specified this protocol codec will also be used to decode tuples with\n   * these names from string multiaddrs.\n   */\n  aliases?: string[]\n\n  /**\n   * Where the multiaddr has been encoded as a string, decode the value if\n   * necessary, unescaping any escaped values\n   */\n  stringToValue?(value: string): string\n\n  /**\n   * To encode the multiaddr as a string, escape any necessary values\n   */\n  valueToString?(value: string): string\n\n  /**\n   * To encode the multiaddr as bytes, convert the value to bytes\n   */\n  valueToBytes?(value: string): Uint8Array\n\n  /**\n   * To decode bytes to a multiaddr, convert the value bytes to a string\n   */\n  bytesToValue?(bytes: Uint8Array): string\n\n  /**\n   * Perform any necessary validation on the string value\n   */\n  validate?(value: string): void\n}\n\nclass Registry implements RegistryInterface {\n  private protocolsByCode = new Map<number, ProtocolCodec>()\n  private protocolsByName = new Map<string, ProtocolCodec>()\n\n  getProtocol (key: string | number): ProtocolCodec {\n    let codec: ProtocolCodec | undefined\n\n    if (typeof key === 'string') {\n      codec = this.protocolsByName.get(key)\n    } else {\n      codec = this.protocolsByCode.get(key)\n    }\n\n    if (codec == null) {\n      throw new UnknownProtocolError(`Protocol ${key} was unknown`)\n    }\n\n    return codec\n  }\n\n  addProtocol (codec: ProtocolCodec): void {\n    this.protocolsByCode.set(codec.code, codec)\n    this.protocolsByName.set(codec.name, codec)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.set(alias, codec)\n    })\n  }\n\n  removeProtocol (code: number): void {\n    const codec = this.protocolsByCode.get(code)\n\n    if (codec == null) {\n      return\n    }\n\n    this.protocolsByCode.delete(codec.code)\n    this.protocolsByName.delete(codec.name)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.delete(alias)\n    })\n  }\n}\n\nexport const registry = new Registry()\n\nconst codecs: ProtocolCodec[] = [{\n  code: CODE_IP4,\n  name: 'ip4',\n  size: 32,\n  valueToBytes: ip4ToBytes,\n  bytesToValue: ip4ToString,\n  validate: (value) => {\n    if (!isIPv4(value)) {\n      throw new ValidationError(`Invalid IPv4 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_TCP,\n  name: 'tcp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDP,\n  name: 'udp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_DCCP,\n  name: 'dccp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_IP6,\n  name: 'ip6',\n  size: 128,\n  valueToBytes: ip6ToBytes,\n  bytesToValue: ip6ToString,\n  stringToValue: ip6StringToValue,\n  validate: (value) => {\n    if (!isIPv6(value)) {\n      throw new ValidationError(`Invalid IPv6 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_IP6ZONE,\n  name: 'ip6zone',\n  size: V\n}, {\n  code: CODE_IPCIDR,\n  name: 'ipcidr',\n  size: 8,\n  bytesToValue: bytesToString('base10'),\n  valueToBytes: stringToBytes('base10')\n}, {\n  code: CODE_DNS,\n  name: 'dns',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNS4,\n  name: 'dns4',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNS6,\n  name: 'dns6',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNSADDR,\n  name: 'dnsaddr',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_SCTP,\n  name: 'sctp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDT,\n  name: 'udt'\n}, {\n  code: CODE_UTP,\n  name: 'utp'\n}, {\n  code: CODE_UNIX,\n  name: 'unix',\n  size: V,\n  path: true,\n  stringToValue: (str) => decodeURIComponent(str),\n  valueToString: (val) => encodeURIComponent(val)\n}, {\n  code: CODE_P2P,\n  name: 'p2p',\n  aliases: ['ipfs'],\n  size: V,\n  bytesToValue: bytesToString('base58btc'),\n  valueToBytes: (val) => {\n    if (val.startsWith('Q') || val.startsWith('1')) {\n      return stringToBytes('base58btc')(val)\n    }\n\n    return CID.parse(val).multihash.bytes\n  }\n}, {\n  code: CODE_ONION,\n  name: 'onion',\n  size: 96,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion2bytes\n}, {\n  code: CODE_ONION3,\n  name: 'onion3',\n  size: 296,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion32bytes\n}, {\n  code: CODE_GARLIC64,\n  name: 'garlic64',\n  size: V\n}, {\n  code: CODE_GARLIC32,\n  name: 'garlic32',\n  size: V\n}, {\n  code: CODE_TLS,\n  name: 'tls'\n}, {\n  code: CODE_SNI,\n  name: 'sni',\n  size: V\n}, {\n  code: CODE_NOISE,\n  name: 'noise'\n}, {\n  code: CODE_QUIC,\n  name: 'quic'\n}, {\n  code: CODE_QUIC_V1,\n  name: 'quic-v1'\n}, {\n  code: CODE_WEBTRANSPORT,\n  name: 'webtransport'\n}, {\n  code: CODE_CERTHASH,\n  name: 'certhash',\n  size: V,\n  bytesToValue: bytes2mb(base64url),\n  valueToBytes: mb2bytes\n}, {\n  code: CODE_HTTP,\n  name: 'http'\n}, {\n  code: CODE_HTTP_PATH,\n  name: 'http-path',\n  size: V,\n  stringToValue: (str) => `/${decodeURIComponent(str)}`,\n  valueToString: (val) => encodeURIComponent(val.substring(1))\n}, {\n  code: CODE_HTTPS,\n  name: 'https'\n}, {\n  code: CODE_WS,\n  name: 'ws'\n}, {\n  code: CODE_WSS,\n  name: 'wss'\n}, {\n  code: CODE_P2P_WEBSOCKET_STAR,\n  name: 'p2p-websocket-star'\n}, {\n  code: CODE_P2P_STARDUST,\n  name: 'p2p-stardust'\n}, {\n  code: CODE_P2P_WEBRTC_STAR,\n  name: 'p2p-webrtc-star'\n}, {\n  code: CODE_P2P_WEBRTC_DIRECT,\n  name: 'p2p-webrtc-direct'\n}, {\n  code: CODE_WEBRTC_DIRECT,\n  name: 'webrtc-direct'\n}, {\n  code: CODE_WEBRTC,\n  name: 'webrtc'\n}, {\n  code: CODE_P2P_CIRCUIT,\n  name: 'p2p-circuit'\n}, {\n  code: CODE_MEMORY,\n  name: 'memory',\n  size: V\n}]\n\ncodecs.forEach(codec => {\n  registry.addProtocol(codec)\n})\n","// the values here come from https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n\nexport const CODE_IP4 = 4\nexport const CODE_TCP = 6\nexport const CODE_UDP = 273\nexport const CODE_DCCP = 33\nexport const CODE_IP6 = 41\nexport const CODE_IP6ZONE = 42\nexport const CODE_IPCIDR = 43\nexport const CODE_DNS = 53\nexport const CODE_DNS4 = 54\nexport const CODE_DNS6 = 55\nexport const CODE_DNSADDR = 56\nexport const CODE_SCTP = 132\nexport const CODE_UDT = 301\nexport const CODE_UTP = 302\nexport const CODE_UNIX = 400\nexport const CODE_P2P = 421 // also IPFS\nexport const CODE_ONION = 444\nexport const CODE_ONION3 = 445\nexport const CODE_GARLIC64 = 446\nexport const CODE_GARLIC32 = 447\nexport const CODE_TLS = 448\nexport const CODE_SNI = 449\nexport const CODE_NOISE = 454\nexport const CODE_QUIC = 460\nexport const CODE_QUIC_V1 = 461\nexport const CODE_WEBTRANSPORT = 465\nexport const CODE_CERTHASH = 466\nexport const CODE_HTTP = 480\nexport const CODE_HTTP_PATH = 481\nexport const CODE_HTTPS = 443\nexport const CODE_WS = 477\nexport const CODE_WSS = 478\nexport const CODE_P2P_WEBSOCKET_STAR = 479\nexport const CODE_P2P_STARDUST = 277\nexport const CODE_P2P_WEBRTC_STAR = 275\nexport const CODE_P2P_WEBRTC_DIRECT = 276\nexport const CODE_WEBRTC_DIRECT = 280\nexport const CODE_WEBRTC = 281\nexport const CODE_P2P_CIRCUIT = 290\nexport const CODE_MEMORY = 777\n","import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport { registry, V } from './registry.ts'\nimport type { Component } from './index.js'\nimport type { ProtocolCodec } from './registry.ts'\n\nexport function bytesToComponents (bytes: Uint8Array): Component[] {\n  const components: Component[] = []\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const codec = registry.getProtocol(code)\n    const codeLength = varint.encodingLength(code)\n    const size = sizeForAddr(codec, bytes, i + codeLength)\n    let sizeLength = 0\n\n    if (size > 0 && codec.size === V) {\n      sizeLength = varint.encodingLength(size)\n    }\n\n    const componentLength = codeLength + sizeLength + size\n\n    const component: Component = {\n      code,\n      name: codec.name,\n      bytes: bytes.subarray(i, i + componentLength)\n    }\n\n    if (size > 0) {\n      const valueOffset = i + codeLength + sizeLength\n      const valueBytes = bytes.subarray(valueOffset, valueOffset + size)\n\n      component.value = codec.bytesToValue?.(valueBytes) ?? uint8ArrayToString(valueBytes)\n    }\n\n    components.push(component)\n\n    i += componentLength\n  }\n\n  return components\n}\n\nexport function componentsToBytes (components: Component[]): Uint8Array {\n  let length = 0\n  const bytes: Uint8Array[] = []\n\n  for (const component of components) {\n    if (component.bytes == null) {\n      const codec = registry.getProtocol(component.code)\n      const codecLength = varint.encodingLength(component.code)\n      let valueBytes: Uint8Array | undefined\n      let valueLength = 0\n      let valueLengthLength = 0\n\n      if (component.value != null) {\n        valueBytes = codec.valueToBytes?.(component.value) ?? uint8ArrayFromString(component.value)\n        valueLength = valueBytes.byteLength\n\n        if (codec.size === V) {\n          valueLengthLength = varint.encodingLength(valueLength)\n        }\n      }\n\n      const bytes = new Uint8Array(codecLength + valueLengthLength + valueLength)\n\n      // encode the protocol code\n      let offset = 0\n      varint.encodeUint8Array(component.code, bytes, offset)\n      offset += codecLength\n\n      // if there is a value\n      if (valueBytes != null) {\n        // if the value has variable length, encode the length\n        if (codec.size === V) {\n          varint.encodeUint8Array(valueLength, bytes, offset)\n          offset += valueLengthLength\n        }\n\n        // finally encode the value\n        bytes.set(valueBytes, offset)\n      }\n\n      component.bytes = bytes\n    }\n\n    bytes.push(component.bytes)\n    length += component.bytes.byteLength\n  }\n\n  return uint8ArrayConcat(bytes, length)\n}\n\nexport function stringToComponents (string: string): Component[] {\n  if (string.charAt(0) !== '/') {\n    throw new InvalidMultiaddrError('String multiaddr must start with \"/\"')\n  }\n\n  const components: Component[] = []\n  let collecting: 'protocol' | 'value' = 'protocol'\n  let value = ''\n  let protocol = ''\n\n  for (let i = 1; i < string.length; i++) {\n    const char = string.charAt(i)\n\n    if (char !== '/') {\n      if (collecting === 'protocol') {\n        protocol += string.charAt(i)\n      } else {\n        value += string.charAt(i)\n      }\n    }\n\n    const ended = i === string.length - 1\n\n    if (char === '/' || ended) {\n      const codec = registry.getProtocol(protocol)\n\n      if (collecting === 'protocol') {\n        if (codec.size == null || codec.size === 0) {\n          // a protocol without an address, eg. `/tls`\n          components.push({\n            code: codec.code,\n            name: codec.name\n          })\n\n          value = ''\n          protocol = ''\n          collecting = 'protocol'\n\n          continue\n        } else if (ended) {\n          throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n        }\n\n        // continue collecting value\n        collecting = 'value'\n      } else if (collecting === 'value') {\n        const component: Component = {\n          code: codec.code,\n          name: codec.name\n        }\n\n        if (codec.size != null && codec.size !== 0) {\n          if (value === '') {\n            throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n          }\n\n          component.value = codec.stringToValue?.(value) ?? value\n        }\n\n        components.push(component)\n\n        value = ''\n        protocol = ''\n        collecting = 'protocol'\n      }\n    }\n  }\n\n  if (protocol !== '' && value !== '') {\n    throw new InvalidMultiaddrError('Incomplete multiaddr')\n  }\n\n  return components\n}\n\nexport function componentsToString (components: Component[]): string {\n  return `/${components.flatMap(component => {\n      if (component.value == null) {\n        return component.name\n      }\n\n      const codec = registry.getProtocol(component.code)\n\n      if (codec == null) {\n        throw new InvalidMultiaddrError(`Unknown protocol code ${component.code}`)\n      }\n\n      return [\n        component.name,\n        codec.valueToString?.(component.value) ?? component.value\n      ]\n    }).join('/')}`\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (codec: ProtocolCodec, bytes: Uint8Array, offset: number): number {\n  if (codec.size == null || codec.size === 0) {\n    return 0\n  }\n\n  if (codec.size > 0) {\n    return codec.size / 8\n  }\n\n  return varint.decode(bytes, offset)\n}\n","import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bytesToComponents, componentsToBytes, componentsToString, stringToComponents } from './components.js'\nimport { CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_P2P, CODE_P2P_CIRCUIT, CODE_TCP, CODE_UDP } from './constants.ts'\nimport { InvalidMultiaddrError, InvalidParametersError } from './errors.ts'\nimport { registry } from './registry.ts'\nimport { isMultiaddr, multiaddr, resolvers } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, MultiaddrObject, Protocol, Tuple, NodeAddress, ResolveOptions, Component } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/multiaddr')\n\nconst DNS_CODES = [\n  CODE_DNS,\n  CODE_DNS4,\n  CODE_DNS6,\n  CODE_DNSADDR\n]\n\nclass NoAvailableResolverError extends Error {\n  constructor (message = 'No available resolver') {\n    super(message)\n    this.name = 'NoAvailableResolverError'\n  }\n}\n\nfunction toComponents (addr: MultiaddrInput): Component[] {\n  if (addr == null) {\n    addr = '/'\n  }\n\n  if (isMultiaddr(addr)) {\n    return addr.getComponents()\n  }\n\n  if (addr instanceof Uint8Array) {\n    return bytesToComponents(addr)\n  }\n\n  if (typeof addr === 'string') {\n    addr = addr\n      .replace(/\\/(\\/)+/, '/')\n      .replace(/(\\/)+$/, '')\n\n    if (addr === '') {\n      addr = '/'\n    }\n\n    return stringToComponents(addr)\n  }\n\n  if (Array.isArray(addr)) {\n    return addr\n  }\n\n  throw new InvalidMultiaddrError('Must be a string, Uint8Array, Component[], or another Multiaddr')\n}\n\ninterface MultiaddrOptions {\n  validate?: boolean\n}\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  [symbol]: boolean = true\n  readonly #components: Component[]\n\n  // cache string representation\n  #string: string | undefined\n  // cache byte representation\n  #bytes: Uint8Array | undefined\n\n  constructor (addr: MultiaddrInput | Component[] = '/', options: MultiaddrOptions = {}) {\n    this.#components = toComponents(addr)\n\n    if (options.validate !== false) {\n      validate(this)\n    }\n  }\n\n  get bytes (): Uint8Array {\n    if (this.#bytes == null) {\n      this.#bytes = componentsToBytes(this.#components)\n    }\n\n    return this.#bytes\n  }\n\n  toString (): string {\n    if (this.#string == null) {\n      this.#string = componentsToString(this.#components)\n    }\n\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  toOptions (): MultiaddrObject {\n    let family: 4 | 6 | undefined\n    let transport: 'tcp' | 'udp' | undefined\n    let host: string | undefined\n    let port: number | undefined\n    let zone = ''\n\n    for (const { code, name, value } of this.#components) {\n      if (code === CODE_IP6ZONE) {\n        zone = `%${value ?? ''}`\n      }\n\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = 'tcp'\n        port = 443\n        host = `${value ?? ''}${zone}`\n        family = code === CODE_DNS6 ? 6 : 4\n      }\n\n      if (code === CODE_TCP || code === CODE_UDP) {\n        transport = name === 'tcp' ? 'tcp' : 'udp'\n        port = parseInt(value ?? '')\n      }\n\n      if (code === CODE_IP4 || code === CODE_IP6) {\n        transport = 'tcp'\n        host = `${value ?? ''}${zone}`\n        family = code === CODE_IP6 ? 6 : 4\n      }\n    }\n\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".')\n    }\n\n    const opts: MultiaddrObject = {\n      family,\n      host,\n      transport,\n      port\n    }\n\n    return opts\n  }\n\n  getComponents (): Component[] {\n    return [\n      ...this.#components\n    ]\n  }\n\n  protos (): Protocol[] {\n    return this.#components.map(({ code, value }) => {\n      const codec = registry.getProtocol(code)\n\n      return {\n        code,\n        size: codec.size ?? 0,\n        name: codec.name,\n        resolvable: Boolean(codec.resolvable),\n        path: Boolean(codec.path)\n      }\n    })\n  }\n\n  protoCodes (): number[] {\n    return this.#components.map(({ code }) => code)\n  }\n\n  protoNames (): string[] {\n    return this.#components.map(({ name }) => name)\n  }\n\n  tuples (): Tuple[] {\n    return this.#components.map(({ code, value }) => {\n      if (value == null) {\n        return [code]\n      }\n\n      const codec = registry.getProtocol(code)\n      const output: Tuple = [code]\n\n      if (value != null) {\n        output.push(codec.valueToBytes?.(value) ?? uint8ArrayFromString(value))\n      }\n\n      return output\n    })\n  }\n\n  stringTuples (): Array<[number, string?]> {\n    return this.#components.map(({ code, value }) => {\n      if (value == null) {\n        return [code]\n      }\n\n      return [code, value]\n    })\n  }\n\n  encapsulate (addr: MultiaddrInput): MultiaddrInterface {\n    const ma = new Multiaddr(addr)\n\n    return new Multiaddr([\n      ...this.#components,\n      ...ma.getComponents()\n    ], {\n      validate: false\n    })\n  }\n\n  decapsulate (addr: Multiaddr | string): MultiaddrInterface {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n\n    if (i < 0) {\n      throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`)\n    }\n\n    return new Multiaddr(s.slice(0, i), {\n      validate: false\n    })\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    let index\n\n    for (let i = this.#components.length - 1; i > -1; i--) {\n      if (this.#components[i].code === code) {\n        index = i\n        break\n      }\n    }\n\n    return new Multiaddr(this.#components.slice(0, index), {\n      validate: false\n    })\n  }\n\n  getPeerId (): string | null {\n    try {\n      let tuples: Array<[number, string | undefined]> = []\n\n      this.#components.forEach(({ code, value }) => {\n        if (code === CODE_P2P) {\n          tuples.push([code, value])\n        }\n\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === CODE_P2P_CIRCUIT) {\n          tuples = []\n        }\n      })\n\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  getPath (): string | null {\n    for (const component of this.#components) {\n      const codec = registry.getProtocol(component.code)\n\n      if (!codec.path) {\n        continue\n      }\n\n      return component.value ?? null\n    }\n\n    return null\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  async resolve (options?: ResolveOptions): Promise<MultiaddrInterface[]> {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (resolver == null) {\n      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`)\n    }\n\n    const result = await resolver(this, options)\n\n    return result.map(str => multiaddr(str))\n  }\n\n  nodeAddress (): NodeAddress {\n    const options = this.toOptions()\n\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`)\n    }\n\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    }\n  }\n\n  isThinWaistAddress (): boolean {\n    if (this.#components.length !== 2) {\n      return false\n    }\n\n    if (this.#components[0].code !== CODE_IP4 && this.#components[0].code !== CODE_IP6) {\n      return false\n    }\n\n    if (this.#components[1].code !== CODE_TCP && this.#components[1].code !== CODE_UDP) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.toString()})`\n  }\n}\n\n/**\n * Ensures all multiaddr tuples are correct. Throws if any invalid protocols or\n * values are encountered.\n */\nexport function validate (addr: Multiaddr): void {\n  addr.getComponents()\n    .forEach(component => {\n      const codec = registry.getProtocol(component.code)\n\n      if (component.value == null) {\n        return\n      }\n\n      codec.validate?.(component.value)\n    })\n}\n","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n","import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\n\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\n\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\n\nexport interface IpNetRaw {\n  network: Uint8Array;\n  mask: Uint8Array;\n}\n\nexport function maskIp(ip: Uint8Array, mask: Uint8Array): Uint8Array {\n  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n    mask = mask.slice(12);\n  }\n  if (\n    mask.length === IPv4Len &&\n    ip.length === IPv6Len &&\n    deepEqual(ip, ipv4Prefix, 0, 11)\n  ) {\n    ip = ip.slice(12);\n  }\n  const n = ip.length;\n  if (n != mask.length) {\n    throw new Error(\"Failed to mask ip\");\n  }\n  const out = new Uint8Array(n);\n  for (let i = 0; i < n; i++) {\n    out[i] = ip[i] & mask[i];\n  }\n  return out;\n}\n\nexport function containsIp(\n  net: IpNetRaw,\n  ip: Uint8Array | number[] | string\n): boolean {\n  if (typeof ip === \"string\") {\n    ip = parseIP(ip)!;\n  }\n  if (ip == null) throw new Error(\"Invalid ip\");\n  if (ip.length !== net.network.length) {\n    return false;\n  }\n  for (let i = 0; i < ip.length; i++) {\n    if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function iPv4FromIPv6(ip: Uint8Array): Uint8Array {\n  if (!isIPv4mappedIPv6(ip)) {\n    throw new Error(\"Must have 0xffff prefix\");\n  }\n  return ip.slice(12);\n}\n\nexport function isIPv4mappedIPv6(ip: Uint8Array | number[]): boolean {\n  return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n","/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const addr = multiaddr('/ip4/127.0.0.1/udp/1234')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddrResolver)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n *   }\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Adding custom protocols\n *\n * To add application-specific or experimental protocols, add a protocol codec\n * to the protocol registry:\n *\n * ```ts\n * import { registry, V, multiaddr } from '@multiformats/multiaddr'\n * import type { ProtocolCodec } from '@multiformats/multiaddr'\n *\n * const maWithCustomTuple = '/custom-protocol/hello'\n *\n * // throws UnknownProtocolError\n * multiaddr(maWithCustomTuple)\n *\n * const protocol: ProtocolCodec = {\n *   code: 2059,\n *   name: 'custom-protocol',\n *   size: V\n *   // V means variable length, can also be 0, a positive integer (e.g. a fixed\n *   // length or omitted\n * }\n *\n * registry.addProtocol(protocol)\n *\n * // does not throw UnknownProtocolError\n * multiaddr(maWithCustomTuple)\n *\n * // protocols can also be removed\n * registry.removeProtocol(protocol.code)\n * ```\n */\n\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidParametersError } from './errors.ts'\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { registry, V } from './registry.ts'\nimport type { ProtocolCodec } from './registry.ts'\nimport type { Resolver } from './resolvers/index.js'\nimport type { DNS } from '@multiformats/dns'\nimport type { AbortOptions } from 'abort-error'\n\n/**\n * Protocols are present in the protocol table\n *\n * @deprecated\n */\nexport interface Protocol {\n  code: number\n  size: number\n  name: string\n  resolvable?: boolean | undefined\n  path?: boolean | undefined\n}\n\n/**\n * A plain JavaScript object representation of a {@link Multiaddr}\n */\nexport interface MultiaddrObject {\n  family: 4 | 6\n  host: string\n  transport: 'tcp' | 'udp'\n  port: number\n}\n\n/**\n * The protocol registry stores protocol codecs that allow transformation of\n * multiaddr tuples from bytes to string and back again, and also validation of\n * the address values.\n */\nexport interface Registry {\n  /**\n   * Retrieve a protocol definition by it's code or name\n   */\n  getProtocol (key: string | number): ProtocolCodec\n\n  /**\n   * Add a new protocol definition\n   */\n  addProtocol (codec: ProtocolCodec): void\n\n  /**\n   * Remove a protocol definition by it's code\n   */\n  removeProtocol (code: number): void\n}\n\n/**\n * A NodeAddress is an IPv4/IPv6 address/TCP port combination\n */\nexport interface NodeAddress {\n  family: 4 | 6\n  address: string\n  port: number\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null | Component[]\n\n/**\n * A code/value pair\n *\n * @deprecated Use Component instead\n */\nexport type Tuple = [number, Uint8Array?]\n\n/**\n * A code/value pair with the value as a string\n *\n * @deprecated Use Component instead\n */\nexport type StringTuple = [number, string?]\n\n/**\n * Allows aborting long-lived operations\n *\n * @deprecated Import from `abort-error` instead\n */\nexport type { AbortOptions }\n\n/**\n * All configured {@link Resolver}s\n *\n * @deprecated DNS resolving will be removed in a future release\n */\nexport const resolvers = new Map<string, Resolver>()\n\nexport type { Resolver }\n\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js'\n\n/**\n * @deprecated DNS resolving will be removed in a future release\n */\nexport interface ResolveOptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\n/**\n * A Component is a section of a multiaddr with a name/code, possibly with a\n * value.\n *\n * Component names/codes are defined in the protocol table.\n *\n * @see https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n */\nexport interface Component {\n  /**\n   * The code of the component as defined in the protocol table\n   */\n  code: number\n\n  /**\n   * The name of the component as defined in the protocol table\n   */\n  name: string\n\n  /**\n   * The component value, if one is present\n   */\n  value?: string\n\n  /**\n   * The bytes that make up the component. This will be set if the multiaddr\n   * was parsed from a `Uint8Array`, or if `.bytes` has been accessed on it.\n   */\n  bytes?: Uint8Array\n}\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns the components that make up this Multiaddr\n   *\n   * @example\n   * ```ts\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').getComponents()\n   * // [{ name: 'ip4', code: 4, value: '127.0.0.1' }, { name: 'tcp', code: 6, value: '4001' }]\n   * ```\n   */\n  getComponents(): Component[]\n\n  /**\n   * Returns Multiaddr as a convenient options object to be used with\n   * `createConnection` from `node:net`\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   * ```\n   */\n  toOptions(): MultiaddrObject\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of\n   * objects, in left-to-right order. Each object contains the protocol code,\n   * protocol name, and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   * ```\n   *\n   * @deprecated Use `getComponents()` instead\n   */\n  protos(): Protocol[]\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   * ```\n   *\n   * @deprecated Use `getComponents()` instead\n   */\n  protoCodes(): number[]\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   * ```\n   *\n   * @deprecated Use `getComponents()` instead\n   */\n  protoNames(): string[]\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   * ```\n   *\n   * @deprecated Use `getComponents()` instead\n   */\n  tuples(): Tuple[]\n\n  /**\n   * Returns a tuple of string/number parts\n   * - tuples[][0] = code of protocol\n   * - tuples[][1] = contents of address\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]\n   * ```\n   *\n   * @deprecated Use `getComponents()` instead\n   */\n  stringTuples(): StringTuple[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a specific\n   * code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string)\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   * ```\n   *\n   * @deprecated A multiaddr can contain multiple PeerIds, use stringTuples() to get a specific one\n   */\n  getPeerId(): string | null\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock)\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   * ```\n   *\n   * @deprecated A multiaddr can contain multiple tuples that could be interpreted as paths, use stringTuples() to get a specific one\n   */\n  getPath(): string | null\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n\n  /**\n   * Resolve multiaddr if containing resolvable hostname.\n   *\n   * @example\n   * ```js\n   * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n   *\n   * resolvers.set('dnsaddr', resolverFunction)\n   * const mh1 = multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n   * const resolvedMultiaddrs = await mh1.resolve()\n   * // [\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb)\n   * // ]\n   * ```\n   *\n   * @deprecated If you need to resolve `dnsaddr` addresses, use `getComponents()` to extract them and perform the resolution yourself\n   */\n  resolve(options?: ResolveOptions): Promise<Multiaddr[]>\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol\n   * information is left out: in Node (and most network systems) the protocol is\n   * unknowable given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 4, address: '127.0.0.1', port: 4001}\n   * ```\n   */\n  nodeAddress(): NodeAddress\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   * const mh2 = multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // Multiaddr(/ip4/192.168.2.1/tcp/5001)\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001)\n   * const mh4 = multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a)\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   * mh4.isThinWaistAddress()\n   * // false\n   * ```\n   */\n  isThinWaistAddress(addr?: Multiaddr): boolean\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress (addr: NodeAddress, transport: string): Multiaddr {\n  if (addr == null) {\n    throw new InvalidParametersError('requires node address object')\n  }\n  if (transport == null) {\n    throw new InvalidParametersError('requires transport protocol')\n  }\n  let ip: string | undefined\n  let host = addr.address\n  switch (addr.family) {\n    case 4:\n      ip = 'ip4'\n      break\n    case 6:\n      ip = 'ip6'\n\n      if (host.includes('%')) {\n        const parts = host.split('%')\n\n        if (parts.length !== 2) {\n          throw Error('Multiple ip6 zones in multiaddr')\n        }\n\n        host = parts[0]\n        const zone = parts[1]\n        ip = `ip6zone/${zone}/ip6`\n      }\n      break\n    default:\n      throw Error('Invalid addr family, should be 4 or 6.')\n  }\n\n  return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'))\n}\n\n/**\n * Create a {@link Multiaddr} from an array of {@link Tuple}s\n *\n * @example\n *\n * ```ts\n * import { fromTuples, multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1')\n * const tuples = ma.tuples()\n *\n * const ma2 = fromTuples(tuples)\n *\n * console.info(ma2)\n * // '/ip4/127.0.0.1'\n * ```\n *\n * @deprecated Will be removed in a future release\n */\nexport function fromTuples (tuples: Tuple[]): Multiaddr {\n  return multiaddr(tuples.map(([code, value]) => {\n    const codec = registry.getProtocol(code)\n\n    const component: Component = {\n      code,\n      name: codec.name\n    }\n\n    if (value != null) {\n      component.value = codec.bytesToValue?.(value) ?? uint8ArrayToString(value)\n    }\n\n    return component\n  }))\n}\n\n/**\n * Create a {@link Multiaddr} from an array of {@link StringTuple}s\n *\n * @example\n *\n * ```ts\n * import { fromStringTuples, multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1')\n * const tuples = ma.stringTuples()\n *\n * const ma2 = fromStringTuples(tuples)\n *\n * console.info(ma2)\n * // '/ip4/127.0.0.1'\n * ```\n *\n * @deprecated Will be removed in a future release\n */\nexport function fromStringTuples (tuples: StringTuple[]): Multiaddr {\n  return multiaddr(tuples.map(([code, value]) => {\n    const codec = registry.getProtocol(code)\n\n    const component: Component = {\n      code,\n      name: codec.name\n    }\n\n    if (value != null) {\n      component.value = value\n    }\n\n    return component\n  }))\n}\n\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n *\n * @deprecated DNS resolving will be removed in a future release\n */\nexport function isName (addr: Multiaddr): boolean {\n  if (!isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n *\n * @deprecated This will be removed in a future version\n */\nexport function protocols (proto: number | string): Protocol {\n  const codec = registry.getProtocol(proto)\n\n  return {\n    code: codec.code,\n    size: codec.size ?? 0,\n    name: codec.name,\n    resolvable: Boolean(codec.resolvable),\n    path: Boolean(codec.path)\n  }\n}\n\n/**\n * Export all table.csv codes. These are all named exports so can be tree-shaken\n * out by bundlers.\n */\nexport * from './constants.ts'\nexport { registry, V }\nexport type { ProtocolCodec }\n","import { multiaddr } from '@multiformats/multiaddr'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface MatchesFunction { (a: string | Uint8Array | Multiaddr): boolean }\nexport interface PartialMatchesFunction { (protos: string[]): boolean | string[] | null }\n\nexport interface Mafmt {\n  toString: () => string\n  input?: Array<(Mafmt | (() => Mafmt))>\n  matches: MatchesFunction\n  partialMatch: PartialMatchesFunction\n}\n\n/*\n * Valid combinations\n */\nexport const DNS4 = base('dns4')\nexport const DNS6 = base('dns6')\nexport const DNSADDR = base('dnsaddr')\nexport const DNS = or(\n  base('dns'),\n  DNSADDR,\n  DNS4,\n  DNS6\n)\n\nexport const IP = or(base('ip4'), base('ip6'))\nexport const TCP = or(\n  and(IP, base('tcp')),\n  and(DNS, base('tcp'))\n)\nexport const UDP = and(IP, base('udp'))\nexport const UTP = and(UDP, base('utp'))\n\nexport const QUIC = and(UDP, base('quic'))\nexport const QUICV1 = and(UDP, base('quic-v1'))\n\nconst _WebSockets = or(\n  and(TCP, base('ws')),\n  and(DNS, base('ws'))\n)\n\nexport const WebSockets = or(\n  and(_WebSockets, base('p2p')),\n  _WebSockets\n)\n\nconst _WebSocketsSecure = or(\n  and(TCP, base('wss')),\n  and(DNS, base('wss')),\n  and(TCP, base('tls'), base('ws')),\n  and(DNS, base('tls'), base('ws'))\n)\n\nexport const WebSocketsSecure = or(\n  and(_WebSocketsSecure, base('p2p')),\n  _WebSocketsSecure\n)\n\nexport const HTTP = or(\n  and(TCP, base('http')),\n  and(IP, base('http')),\n  and(DNS, base('http'))\n)\n\nexport const HTTPS = or(\n  and(TCP, base('https')),\n  and(IP, base('https')),\n  and(DNS, base('https'))\n)\n\nconst _WebRTCDirect = and(UDP, base('webrtc-direct'), base('certhash'))\nexport const WebRTCDirect = or(\n  and(_WebRTCDirect, base('p2p')),\n  _WebRTCDirect\n)\n\nconst _WebTransport = and(QUICV1, base('webtransport'), base('certhash'), base('certhash'))\nexport const WebTransport = or(\n  and(_WebTransport, base('p2p')),\n  _WebTransport\n)\n\n/**\n * @deprecated\n */\nexport const P2PWebRTCStar = or(\n  and(WebSockets, base('p2p-webrtc-star'), base('p2p')),\n  and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')),\n  and(WebSockets, base('p2p-webrtc-star')),\n  and(WebSocketsSecure, base('p2p-webrtc-star'))\n)\n\nexport const WebSocketStar = or(\n  and(WebSockets, base('p2p-websocket-star'), base('p2p')),\n  and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')),\n  and(WebSockets, base('p2p-websocket-star')),\n  and(WebSocketsSecure, base('p2p-websocket-star'))\n)\n\n/**\n * @deprecated\n */\nexport const P2PWebRTCDirect = or(\n  and(HTTP, base('p2p-webrtc-direct'), base('p2p')),\n  and(HTTPS, base('p2p-webrtc-direct'), base('p2p')),\n  and(HTTP, base('p2p-webrtc-direct')),\n  and(HTTPS, base('p2p-webrtc-direct'))\n)\n\nexport const Reliable = or(\n  _WebSockets,\n  _WebSocketsSecure,\n  HTTP,\n  HTTPS,\n  P2PWebRTCStar,\n  P2PWebRTCDirect,\n  TCP,\n  UTP,\n  QUIC,\n  DNS,\n  WebRTCDirect,\n  WebTransport\n)\n\n// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\nexport const Stardust = or(\n  and(Reliable, base('p2p-stardust'), base('p2p')),\n  and(Reliable, base('p2p-stardust'))\n)\n\nconst _P2P = or(\n  and(Reliable, base('p2p')),\n  P2PWebRTCStar,\n  P2PWebRTCDirect,\n  WebRTCDirect,\n  WebTransport,\n  base('p2p')\n)\n\nconst _Circuit = or(\n  and(_P2P, base('p2p-circuit'), _P2P),\n  and(_P2P, base('p2p-circuit')),\n  and(base('p2p-circuit'), _P2P),\n  and(Reliable, base('p2p-circuit')),\n  and(base('p2p-circuit'), Reliable),\n  base('p2p-circuit')\n)\n\nconst CircuitRecursive = (): Mafmt => or(\n  and(_Circuit, CircuitRecursive),\n  _Circuit\n)\n\nexport const Circuit = CircuitRecursive()\n\nexport const P2P = or(\n  and(Circuit, _P2P, Circuit),\n  and(_P2P, Circuit),\n  and(Circuit, _P2P),\n  Circuit,\n  _P2P\n)\n\nexport const IPFS = P2P\n\nexport const WebRTC = or(\n  and(Circuit, base('webrtc'), base('p2p')),\n  and(Circuit, base('webrtc')),\n  and(Reliable, base('webrtc'), base('p2p')),\n  and(Reliable, base('webrtc')),\n  base('webrtc')\n)\n\n/*\n * Validation funcs\n */\n\nfunction makeMatchesFunction (partialMatch: PartialMatchesFunction): (a: string | Uint8Array | Multiaddr) => boolean {\n  function matches (a: string | Uint8Array | Multiaddr): boolean {\n    let ma\n\n    try {\n      ma = multiaddr(a)\n    } catch (err: any) { // catch error\n      return false // also if it's invalid it's probably not matching as well so return false\n    }\n\n    const out = partialMatch(ma.protoNames())\n    if (out === null) {\n      return false\n    }\n\n    if (out === true || out === false) {\n      return out\n    }\n\n    return out.length === 0\n  }\n\n  return matches\n}\n\nfunction and (...args: Array<Mafmt | (() => Mafmt)>): Mafmt {\n  function partialMatch (a: string[]): boolean | string[] | null {\n    if (a.length < args.length) {\n      return null\n    }\n\n    let out: boolean | string[] | null = a\n\n    args.some((arg) => {\n      out = typeof arg === 'function'\n        ? arg().partialMatch(a)\n        : arg.partialMatch(a)\n\n      if (Array.isArray(out)) {\n        a = out\n      }\n\n      if (out === null) {\n        return true\n      }\n\n      return false\n    })\n\n    return out\n  }\n\n  return {\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch\n  }\n}\n\nfunction or (...args: Array<Mafmt | (() => Mafmt)>): Mafmt {\n  function partialMatch (a: string[]): boolean | string[] | null {\n    let out = null\n    args.some((arg) => {\n      const res = typeof arg === 'function'\n        ? arg().partialMatch(a)\n        : arg.partialMatch(a)\n      if (res != null) {\n        out = res\n        return true\n      }\n      return false\n    })\n\n    return out\n  }\n\n  const result = {\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch\n  }\n\n  return result\n}\n\nfunction base (n: string): Mafmt {\n  const name = n\n\n  function matches (a: string | Uint8Array | Multiaddr): boolean {\n    let ma: Multiaddr\n\n    try {\n      ma = multiaddr(a)\n    } catch (err: any) { // catch error\n      return false // also if it's invalid it's probably not matching as well so return false\n    }\n\n    const pnames = ma.protoNames()\n    if (pnames.length === 1 && pnames[0] === name) {\n      return true\n    }\n    return false\n  }\n\n  function partialMatch (protos: string[]): boolean | string[] | null {\n    if (protos.length === 0) {\n      return null\n    }\n\n    if (protos[0] === name) {\n      return protos.slice(1)\n    }\n    return null\n  }\n\n  return {\n    toString: function () { return name },\n    matches,\n    partialMatch\n  }\n}\n","/**\n * @packageDocumentation\n *\n * A suite of util methods that provides efficient validation.\n *\n * Detection of IPFS Paths and identifiers in URLs is a two-stage process:\n *\n * 1. `pathPattern`/`pathGatewayPattern`/`subdomainGatewayPattern` regex is applied to quickly identify potential candidates\n * 2. proper CID validation is applied to remove false-positives\n *\n * @example\n *\n * ```TypeScript\n * import * as isIPFS from 'is-ipfs'\n *\n * isIPFS.multihash('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.multihash('noop') // false\n *\n * isIPFS.cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true (CIDv0)\n * isIPFS.cid('bafybeiasb5vpmaounyilfuxbd3lryvosl4yefqrfahsb2esg46q6tu6y5q') // true (CIDv1 in Base32)\n * isIPFS.cid('zdj7WWeQ43G6JJvLWQWZpyHuAMq6uYWRjkBXFad11vE2LHhQ7') // true (CIDv1 in Base58btc)\n * isIPFS.cid('noop') // false\n *\n * isIPFS.base32cid('bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va') // true\n * isIPFS.base32cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n *\n * isIPFS.url('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.url('https://ipfs.io/ipfs/QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR?filename=guardian.jpg') // true\n * isIPFS.url('https://ipfs.io/ipns/github.com') // true\n * isIPFS.url('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.url('http://en.wikipedia-on-ipfs.org.ipfs.localhost:8080') // true\n * isIPFS.url('https://github.com/ipfs/js-ipfs/blob/master/README.md') // false\n * isIPFS.url('https://google.com') // false\n *\n * isIPFS.path('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.path('/ipfs/QmbcBPAwCDxRMB1Qe7CRQmxdrTSkxKwM9y6rZw2FjGtbsb/?weird-filename=test.jpg') // true\n * isIPFS.path('/ipns/github.com') // true\n * isIPFS.path('/ipfs/js-ipfs/blob/master/README.md') // false\n *\n * isIPFS.urlOrPath('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('https://ipfs.io/ipns/github.com') // true\n * isIPFS.urlOrPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('/ipns/github.com') // true\n * isIPFS.urlOrPath('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.urlOrPath('https://google.com') // false\n *\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsUrl('https://ipfs.io/ipns/github.com') // true\n *\n * isIPFS.ipfsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsPath('/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsPath('/ipns/github.com') // true\n *\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/path/to/file') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/file') // false\n *\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.subdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.subdomain('http://www.bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // false\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://QmcNioXSC1bfJj1dcFErhUfyjFzoX2HodkRccsFFVJJvg8.ipns.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://en.wikipedia-on-ipfs.org.ipns.localhost:8080') // true (assuming DNSLink)\n * isIPFS.ipnsSubdomain('http://en-wikipedia--on--ipfs-org.ipns.localhost:8080') // true (assuming inlined DNSLink)\n * isIPFS.ipnsSubdomain('http://hostname-without-tld-.ipns.dweb.link') // false (not a CID, invalid DNS label)\n *\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234') // true\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234/http') // true\n * isIPFS.multiaddr('/ip6/::1/udp/1234') // true\n * isIPFS.multiaddr('ip6/::1/udp/1234') // false\n * isIPFS.multiaddr('/yoloinvalid/::1/udp/1234') // false\n *\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true\n * isIPFS.peerMultiaddr('/ipfs/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true (legacy notation)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/tcp/1234/ws/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4/p2p-circuit/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io') // false (key missing, needs additional DNS lookup to tell if this is valid)\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN') // true (key present, ip and port can be resolved later)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/udp/1234') // false (key missing)\n * ```\n */\n\nimport * as mafmt from '@multiformats/mafmt'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { URL } from 'iso-url'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\nfunction isMultihash (hash: Uint8Array | string): boolean {\n  const formatted = convertToString(hash)\n\n  if (formatted === false) {\n    return false\n  }\n\n  try {\n    Digest.decode(base58btc.decode(`z${formatted}`))\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isMultiaddr (input: string | Uint8Array | Multiaddr): input is Multiaddr {\n  try {\n    return Boolean(multiaddr(input))\n  } catch {\n    return false\n  }\n}\n\nfunction isBase32EncodedMultibase (hash: CID | string | Uint8Array): boolean {\n  try {\n    let cid: CID | null\n\n    if (isString(hash)) {\n      cid = CID.parse(hash)\n    } else {\n      cid = CID.asCID(hash)\n    }\n\n    if (cid == null) {\n      return false\n    }\n\n    base32.decode(cid.toString())\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isCID (hash: CID | Uint8Array | string): hash is CID {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash))\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash))\n    }\n\n    return Boolean(CID.asCID(hash)) // eslint-disable-line no-new\n  } catch {\n    return false\n  }\n}\n\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr (input: string | Uint8Array | Multiaddr): boolean {\n  return isMultiaddr(input) && mafmt.P2P.matches(input)\n}\n\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath): boolean {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath): boolean {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org  en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-')\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {any} input\n */\nfunction isString (input: any): input is string {\n  return typeof input === 'string'\n}\n\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString (input: Uint8Array | string): string | false {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc')\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS subdomain\n * (case-insensitive CIDv1) or `false` otherwise.\n */\nexport const ipfsSubdomain = (url: string | Uint8Array): boolean => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n\n/**\n * Returns `true` if the provided `url` string looks like a valid IPNS subdomain\n * (CIDv1 with `libp2p-key` multicodec or something that looks like a FQDN, for\n * example `en.wikipedia-on-ipfs.org.ipns.localhost:8080`) or `false` otherwise.\n *\n * **Note:** `ipnsSubdomain` method works in offline mode: it does not perform\n * actual IPNS record lookup over DHT or other content routing method. It may\n * return false-positives:\n *\n * - To ensure IPNS record  exists, make a call to `/api/v0/name/resolve?arg=<ipnsid>`\n * - To ensure DNSLink exists, make a call to `/api/v0/dns?arg=<fqdn>`\n */\nexport const ipnsSubdomain = (url: string | Uint8Array): boolean => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS, looks like\n * an IPNS/DNSLink subdomain or `false` otherwise.\n */\nexport const subdomain = (url: string | Uint8Array): boolean => ipfsSubdomain(url) || ipnsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPFS url or `false`\n * otherwise.\n */\nexport const ipfsUrl = (url: string | Uint8Array): boolean => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPNS url or `false`\n * otherwise.\n */\nexport const ipnsUrl = (url: string | Uint8Array): boolean => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or `false`\n * otherwise.\n */\nexport const url = (url: string | Uint8Array): boolean => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\nexport const path = (path: string | Uint8Array): boolean => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\n/**\n * Returns `true` if the provided string or `Uint8Array`  is a valid `multihash`\n * or `false` otherwise.\n */\nexport { isMultihash as multihash }\n\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid multiaddr or `false` otherwise.\n */\nexport { isMultiaddr as multiaddr }\n\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid libp2p peer multiaddr (matching [`P2P`\n * format from `mafmt`](https://github.com/multiformats/js-mafmt#api)) or\n * `false` otherwise.\n */\nexport { isPeerMultiaddr as peerMultiaddr }\n\n/**\n * Returns `true` if the provided string, `Uint8Array` or [`CID`](https://github.com/multiformats/js-multiformats/#readme)\n * object represents a valid [CID](https://docs.ipfs.io/guides/concepts/cid/) or\n * `false` otherwise.\n */\nexport { isCID as cid }\n\n/**\n * Returns `true` if the provided string is a valid `CID` in Base32 encoding or\n * `false` otherwise.\n */\nexport const base32cid = (cid: CID | string | Uint8Array): boolean => (isCID(cid) && isBase32EncodedMultibase(cid))\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS path or `false`\n * otherwise.\n */\nexport const ipfsPath = (path: string | Uint8Array): boolean => isIpfs(path, pathPattern)\n\n/**\n * Returns `true` if the provided string is a valid IPNS path or `false`\n * otherwise.\n */\nexport const ipnsPath = (path: string | Uint8Array): boolean => isIpns(path, pathPattern)\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or path or\n * `false` otherwise.\n */\nexport const urlOrPath = (x: string | Uint8Array): boolean => url(x) || path(x)\n\n/**\n * Returns `true` if the provided string is a valid \"CID path\" (IPFS path\n * without `/ipfs/` prefix) or `false` otherwise.\n */\nexport const cidPath = (path: string | Uint8Array | CID): boolean => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n","'use strict'\n\nconst isReactNative =\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative'\n\nfunction getDefaultBase () {\n  if (isReactNative) {\n    return 'http://localhost'\n  }\n  // in some environments i.e. cloudflare workers location is not available\n  if (!self.location) {\n    return ''\n  }\n\n  return self.location.protocol + '//' + self.location.host\n}\n\nconst URL = self.URL\nconst defaultBase = getDefaultBase()\n\nclass URLWithLegacySupport {\n  constructor (url = '', base = defaultBase) {\n    this.super = new URL(url, base)\n    this.path = this.pathname + this.search\n    this.auth =\n            this.username && this.password\n              ? this.username + ':' + this.password\n              : null\n\n    this.query =\n            this.search && this.search.startsWith('?')\n              ? this.search.slice(1)\n              : null\n  }\n\n  get hash () {\n    return this.super.hash\n  }\n\n  get host () {\n    return this.super.host\n  }\n\n  get hostname () {\n    return this.super.hostname\n  }\n\n  get href () {\n    return this.super.href\n  }\n\n  get origin () {\n    return this.super.origin\n  }\n\n  get password () {\n    return this.super.password\n  }\n\n  get pathname () {\n    return this.super.pathname\n  }\n\n  get port () {\n    return this.super.port\n  }\n\n  get protocol () {\n    return this.super.protocol\n  }\n\n  get search () {\n    return this.super.search\n  }\n\n  get searchParams () {\n    return this.super.searchParams\n  }\n\n  get username () {\n    return this.super.username\n  }\n\n  set hash (hash) {\n    this.super.hash = hash\n  }\n\n  set host (host) {\n    this.super.host = host\n  }\n\n  set hostname (hostname) {\n    this.super.hostname = hostname\n  }\n\n  set href (href) {\n    this.super.href = href\n  }\n\n  set password (password) {\n    this.super.password = password\n  }\n\n  set pathname (pathname) {\n    this.super.pathname = pathname\n  }\n\n  set port (port) {\n    this.super.port = port\n  }\n\n  set protocol (protocol) {\n    this.super.protocol = protocol\n  }\n\n  set search (search) {\n    this.super.search = search\n  }\n\n  set username (username) {\n    this.super.username = username\n  }\n\n  /**\n   * @param {any} o\n   */\n  static createObjectURL (o) {\n    return URL.createObjectURL(o)\n  }\n\n  /**\n   * @param {string} o\n   */\n  static revokeObjectURL (o) {\n    URL.revokeObjectURL(o)\n  }\n\n  toJSON () {\n    return this.super.toJSON()\n  }\n\n  toString () {\n    return this.super.toString()\n  }\n\n  format () {\n    return this.toString()\n  }\n}\n\n/**\n * @param {string | import('url').UrlObject} obj\n */\nfunction format (obj) {\n  if (typeof obj === 'string') {\n    const url = new URL(obj)\n\n    return url.toString()\n  }\n\n  if (!(obj instanceof URL)) {\n    const userPass =\n            // @ts-ignore its not supported in node but we normalise\n            obj.username && obj.password\n              // @ts-ignore its not supported in node but we normalise\n              ? `${obj.username}:${obj.password}@`\n              : ''\n    const auth = obj.auth ? obj.auth + '@' : ''\n    const port = obj.port ? ':' + obj.port : ''\n    const protocol = obj.protocol ? obj.protocol + '//' : ''\n    const host = obj.host || ''\n    const hostname = obj.hostname || ''\n    const search = obj.search || (obj.query ? '?' + obj.query : '')\n    const hash = obj.hash || ''\n    const pathname = obj.pathname || ''\n    // @ts-ignore - path is not supported in node but we normalise\n    const path = obj.path || pathname + search\n\n    return `${protocol}${userPass || auth}${\n            host || hostname + port\n        }${path}${hash}`\n  }\n}\n\nmodule.exports = {\n  URLWithLegacySupport,\n  URLSearchParams: self.URLSearchParams,\n  defaultBase,\n  format\n}\n","'use strict'\n\nconst { URLWithLegacySupport, format } = require('./url')\n\n/**\n * @param {string | undefined} url\n * @param {any} [location]\n * @param {any} [protocolMap]\n * @param {any} [defaultProtocol]\n */\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n  let protocol = location.protocol\n    ? location.protocol.replace(':', '')\n    : 'http'\n\n  // Check protocol map\n  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'\n  let urlParsed\n\n  try {\n    urlParsed = new URLWithLegacySupport(url)\n  } catch (err) {\n    urlParsed = {}\n  }\n\n  const base = Object.assign({}, location, {\n    protocol: protocol || urlParsed.protocol,\n    host: location.host || urlParsed.host\n  })\n\n  return new URLWithLegacySupport(url, format(base)).toString()\n}\n","'use strict'\n\nconst {\n  URLWithLegacySupport,\n  format,\n  URLSearchParams,\n  defaultBase\n} = require('./src/url')\nconst relative = require('./src/relative')\n\nmodule.exports = {\n  URL: URLWithLegacySupport,\n  URLSearchParams,\n  format,\n  relative,\n  defaultBase\n}\n"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","toPropertyKey","t","i","r","e","toPrimitive","call","TypeError","String","Number","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","Uint8Array","coerce","name","ArrayBuffer","isView","buffer","byteOffset","byteLength","Error","src","ALPHABET","BASE_MAP","j","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","size","b256","carry","it3","it4","vch","encode","Array","isArray","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","concat","Encoder","prefix","baseEncode","_defineProperty","this","bytes","Decoder","baseDecode","prefixCodePoint","codePointAt","undefined","text","JSON","stringify","slice","or","decoder","ComposedDecoder","decoders","input","RangeError","left","right","_left$decoders","_right$decoders","_objectSpread","Codec","encoder","_ref","baseX","_ref2","alphabet","basex","rfc4648","_ref3","bitsPerChar","alphabetIdx","createAlphabetIdx","data","pad","mask","out","bits","end","written","SyntaxError","base10","base16","base16upper","base2","alphabetBytesToChars","reduce","p","c","alphabetCharsToBytes","codePoint","base256emoji","byts","char","byt","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","base36","base36upper","base58btc","base58flickr","base64","base64pad","base64url","base64urlpad","base8","identity","buf","toString","b","TextDecoder","TextEncoder","fromString","textEncoder","textDecoder","code","node","parse","encode_1","num","offset","oldOffset","INT","MSB","MSBALL","pow","read","res","shift","counter","l","REST$1","MSB$1","N1","N2","N3","N4","N5","N6","N7","N8","N9","encodingLength","varint","encodeTo","int","target","create","digest","sizeOffset","digestOffset","set","Digest","multihash","subarray","options","truncate","minDigestLength","maxDigestLength","Hasher","result","createDigest","then","sha","async","crypto","subtle","sha256","sha512","format","link","base","version","cache","cid","get","toStringV0","baseCache","toStringV1","WeakMap","Map","CID","toStringTag","asCID","toV0","DAG_PB_CODE","SHA_256_CODE","createV0","toV1","createV1","equals","other","self","unknown","a","aa","bb","ii","equalBytes","toJSON","for","encodeCID","cidSymbol","remainder","decodeFirst","specs","inspectBytes","prefixSize","multihashSize","multihashBytes","digestBytes","digestSize","multihashCode","codec","initialBytes","next","parseCIDtoBytes","codeOffset","hashOffset","bases","identityBase","base58","sha2","allocUnsafe","createCodec","substring","ascii","fromCharCode","utf8","hex","latin1","binary","array","encoding","InvalidMultiaddrError","ValidationError","InvalidParametersError","UnknownProtocolError","_classPrivateFieldInitSpec","has","_assertClassBrand","n","_classPrivateFieldGet2","s","_classPrivateFieldSet2","REST","MAX_SAFE_INTEGER","encodeUint8Array","decodeUint8Array","decodeUint8ArrayList","arrays","acc","curr","output","arr","parser","new","index","readAtomically","fn","parseWith","peekChar","readChar","readGivenChar","readSeparator","sep","inner","readNumber","radix","maxDigits","allowZeroPrefix","maxBytes","digitCount","leadingChar","hasLeadingZero","maxValue","digit","parseInt","isNaN","readIPv4Addr","ix","readIPv6Addr","readGroups","groups","ipv4","group","head","headSize","headIp4","tail","limit","tailSize","readIPAddr","_this$readIPv4Addr","isIPv4","Boolean","parseIPv4","isIPv6","includes","split","parseIPv6","bytesToString","uint8ArrayToString","stringToBytes","uint8ArrayFromString","bytes2port","DataView","getUint16","port2bytes","port","setUint16","bytes2onion","addrBytes","portBytes","addr","ip4ToBytes","ip","trim","byte","values","map","anybaseDecoder","d","validatePort","_len","funcs","_key","validate","max","V","registry","getProtocol","key","protocolsByName","protocolsByCode","addProtocol","_codec$aliases","aliases","alias","removeProtocol","_codec$aliases2","delete","codecs","valueToBytes","bytesToValue","join","sections","v4Buffer","splice","unshift","argv","word","byte1","byte2","tuple","padStart","url","URL","hostname","_unused","stringToValue","_unused2","resolvable","path","decodeURIComponent","valueToString","val","encodeURIComponent","startsWith","portBuf","uint8ArrayConcat","bytes2mb","mbstr","sizeForAddr","inspect","symbol","DNS_CODES","NoAvailableResolverError","super","toComponents","isMultiaddr","getComponents","components","codeLength","sizeLength","componentLength","component","_codec$bytesToValue","_codec$bytesToValue2","valueOffset","valueBytes","bytesToComponents","replace","collecting","protocol","ended","_codec$stringToValue","_codec$stringToValue2","stringToComponents","_components","_string","_bytes","Multiaddr","_classPrivateFieldSet","_codec$validate","_classPrivateFieldGet","codecLength","valueLength","valueLengthLength","_codec$valueToBytes","_codec$valueToBytes2","componentsToBytes","flatMap","_codec$valueToString","_codec$valueToString2","toOptions","family","transport","host","zone","protos","_codec$size","protoCodes","protoNames","tuples","_ref4","stringTuples","_ref5","encapsulate","ma","decapsulate","addrString","lastIndexOf","decapsulateCode","getPeerId","_ref6","pop","peerIdStr","getPath","_component$value","uint8ArrayEquals","resolve","resolvableProto","find","resolver","resolvers","multiaddr","nodeAddress","address","isThinWaistAddress","MultiaddrClass","DNS4","DNS6","DNSADDR","DNS","IP","TCP","and","UDP","UTP","QUIC","QUICV1","_WebSockets","WebSockets","_WebSocketsSecure","WebSocketsSecure","HTTP","HTTPS","_WebRTCDirect","WebRTCDirect","_WebTransport","WebTransport","P2PWebRTCStar","P2PWebRTCDirect","Reliable","_P2P","_Circuit","CircuitRecursive","Circuit","P2P","makeMatchesFunction","partialMatch","err","args","some","arg","matches","_len2","_key2","pnames","pathGatewayPattern","pathPattern","subdomainGatewayPattern","fqdnWithTld","isMultihash","hash","formatted","convertToString","isCID","isString","_unused4","isPeerMultiaddr","mafmt","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","ipnsId","test","ipfsSubdomain","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","base32cid","_unused3","isBase32EncodedMultibase","ipfsPath","ipnsPath","urlOrPath","cidPath","isReactNative","navigator","product","defaultBase","location","module","exports","URLWithLegacySupport","pathname","search","auth","username","password","query","href","origin","searchParams","createObjectURL","revokeObjectURL","URLSearchParams","obj","userPass","require","urlParsed","protocolMap","defaultProtocol","assign","relative"],"sourceRoot":""}